# 库存点合并逻辑设计文档

## 项目概述

基于对现有data-update项目和data_project项目的分析，为data-update项目添加库存点合并逻辑，实现欧盟和非欧盟地区的库存数据合并功能，提升数据处理效率和准确性。

## 1. 需求分析

### 1.1 核心需求
基于data_project/Readme.md的需求分析，需要实现以下库存点合并逻辑：

#### 欧盟地区合并逻辑
- **两步合并流程**：
  1. **第一步**：每个店铺从所有后缀中选出"FBA可用+FBA在途"之和最大的国家作为该店铺的最佳库存代表
  2. **第二步**：将同一个ASIN在每个店铺的最佳库存代表进行合并，形成同一个ASIN在欧盟的库存点

- **欧盟国家识别**：包含FR、DE、IT、ES、PT、NL、BE、LU、AT、DK、SE、FI、EE、HR、SI、CZ、RO、BG、GR、CY、MT、IS、LI、MC、SM、VA等后缀的店铺
- **累加规则**：FBA可用分别累加、FBA在途分别累加、本地仓可用不累加（国内同一个仓库）
- **显示方式**：欧盟地区统一显示为"欧盟"

#### 非欧盟地区合并逻辑
- **范围**：CA、US、UK、AU等非欧盟地区
- **合并规则**：识别同一ASIN在同一个国家的不同店名前缀下的库存和销量
- **数据处理**：销量加总、库存加总（FBA可用和FBA在途分别展示）

#### 广告数据合并
- **合并字段**：广告曝光量、广告点击量、广告花费、广告订单量进行加总
- **计算字段**：
  - 广告点击率 = 广告点击量/广告曝光量
  - 广告转化率 = 广告订单量/广告点击量  
  - ACOAS = 广告花费/(日均销售额*7)

### 1.2 业务价值
- 消除重复库存计算，提供准确的库存视图
- 支持跨店铺、跨地区的库存分析
- 为业务决策提供精确的数据基础

## 2. 技术债务评估

### 2.1 现有data-update项目分析

#### 优势
- **完善的架构设计**：采用分层架构，模块划分清晰
- **丰富的功能模块**：包含认证、解析、抓取、处理、调度等完整功能
- **良好的可扩展性**：支持多种数据源和处理器
- **完善的错误处理**：包含重试机制和异常处理

#### 技术债务识别

##### 高优先级债务
1. **缺少库存点合并逻辑**
   - 当前项目主要关注数据同步，缺少复杂的数据合并和分析功能
   - 需要增加inventory_merger模块

2. **数据模型不完整**
   - 缺少合并后的库存点数据模型
   - 需要扩展现有模型以支持合并逻辑

3. **处理器功能局限**
   - 现有处理器主要做基础的数据清洗
   - 需要增加专门的库存合并处理器

##### 中优先级债务
1. **API文档解析局限**
   - 主要解析基础的API接口信息
   - 对复杂业务逻辑支持不足

2. **测试覆盖不足**
   - 集成测试相对简单
   - 缺少复杂业务逻辑的测试用例

##### 低优先级债务
1. **监控和告警机制**
   - 基础的日志记录功能
   - 可进一步增强业务监控指标

2. **性能优化空间**
   - 当前主要关注数据同步性能
   - 对复杂计算的性能优化还有空间

### 2.2 改进建议

#### 短期改进（1-2周）
- 增加inventory_merger模块
- 扩展数据模型
- 添加合并处理器

#### 中期改进（1个月）  
- 完善测试覆盖
- 优化性能
- 增强监控

#### 长期改进（2-3个月）
- 微服务化改造
- 增加更多数据源支持
- 构建完整的数据平台

## 3. 微服务架构设计

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    API Gateway                              │
│                  (Nginx/Kong)                              │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                   服务发现与配置中心                         │
│                (Consul/Nacos/Etcd)                         │
└─────────────────────────────────────────────────────────────┘
                               │
        ┌──────────────────────┼──────────────────────┐
        ▼                      ▼                      ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│   数据同步服务    │  │   数据处理服务    │  │   库存合并服务    │
│ data-sync-svc   │  │ data-proc-svc   │  │inventory-merge  │
│                 │  │                 │  │    -svc         │
└─────────────────┘  └─────────────────┘  └─────────────────┘
        │                      │                      │
        └──────────────────────┼──────────────────────┘
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                     消息队列                                │
│                (RabbitMQ/Kafka)                            │
└─────────────────────────────────────────────────────────────┘
                               │
        ┌──────────────────────┼──────────────────────┐
        ▼                      ▼                      ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│   分析服务       │  │   报表服务       │  │   通知服务       │
│ analysis-svc    │  │ report-svc      │  │notification-svc │
└─────────────────┘  └─────────────────┘  └─────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                     数据存储层                              │
│         MySQL + Redis + ClickHouse                         │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心服务详细设计

#### 3.2.1 数据同步服务 (data-sync-service)
- **职责**：负责从外部API抓取原始数据
- **技术栈**：Python FastAPI + Celery
- **核心功能**：
  - API数据抓取
  - 数据校验和清洗
  - 批量数据处理
  - 错误重试机制

#### 3.2.2 库存合并服务 (inventory-merge-service)
- **职责**：实现复杂的库存点合并逻辑
- **技术栈**：Python FastAPI + NumPy/Pandas
- **核心功能**：
  - 欧盟地区库存合并
  - 非欧盟地区库存合并
  - 广告数据合并
  - 合并规则配置

#### 3.2.3 数据处理服务 (data-processing-service)  
- **职责**：数据转换和业务逻辑处理
- **技术栈**：Python FastAPI + SQLAlchemy
- **核心功能**：
  - 数据格式转换
  - 业务规则验证
  - 数据增强
  - 质量监控

#### 3.2.4 分析服务 (analysis-service)
- **职责**：库存分析和统计计算
- **技术栈**：Python FastAPI + ClickHouse
- **核心功能**：
  - 库存周转分析
  - 统计指标计算
  - 趋势分析
  - 异常检测

#### 3.2.5 报表服务 (report-service)
- **职责**：报表生成和数据展示
- **技术栈**：Node.js Express + Vue.js
- **核心功能**：
  - 动态报表生成
  - 数据可视化
  - Excel导出
  - 用户交互

### 3.3 数据流设计

```
外部API → 数据同步服务 → 消息队列 → 数据处理服务 → 库存合并服务 → 分析服务 → 报表服务
    │                                                                            │
    └─────────────────── 数据存储层 ←───────────────────────────────────────────────┘
```

## 4. 系统演进路线图

### 4.1 Phase 1: 基础功能增强 (Week 1-2)

#### 目标
在现有data-update项目基础上添加库存点合并功能

#### 关键任务
1. **创建inventory_merger模块**
   ```python
   src/
   ├── inventory/
   │   ├── __init__.py
   │   ├── merger.py           # 库存合并核心逻辑
   │   ├── eu_merger.py        # 欧盟地区合并
   │   ├── non_eu_merger.py    # 非欧盟地区合并
   │   └── ad_merger.py        # 广告数据合并
   ```

2. **扩展数据模型**
   ```python
   # src/models/inventory_point.py
   class InventoryPoint(Base):
       id = Column(Integer, primary_key=True)
       asin = Column(String(20), nullable=False)
       marketplace = Column(String(50), nullable=False)
       merged_fba_available = Column(Integer, default=0)
       merged_fba_inbound = Column(Integer, default=0)
       # ... 其他字段
   ```

3. **新增合并处理器**
   ```python
   # src/processors/inventory_merge_processor.py
   class InventoryMergeProcessor(BaseProcessor):
       def process(self, data):
           # 实现库存合并逻辑
           pass
   ```

#### 交付物
- 功能完整的库存合并模块
- 单元测试覆盖
- 基础文档

### 4.2 Phase 2: 性能优化和完善 (Week 3-4)

#### 目标
优化合并性能，完善业务逻辑

#### 关键任务
1. **性能优化**
   - 数据批处理优化
   - 内存使用优化
   - 数据库查询优化

2. **业务逻辑完善**
   - 异常情况处理
   - 数据校验增强
   - 配置化规则

3. **监控增强**
   - 合并性能监控
   - 数据质量监控
   - 业务指标监控

#### 交付物
- 性能优化的合并系统
- 完善的监控体系
- 运维文档

### 4.3 Phase 3: 微服务改造准备 (Month 2)

#### 目标
为微服务化做好技术和架构准备

#### 关键任务
1. **接口标准化**
   - 定义标准API接口
   - 统一数据格式
   - 版本管理策略

2. **服务解耦**
   - 识别服务边界
   - 抽取公共组件
   - 数据依赖分析

3. **基础设施准备**
   - 容器化改造
   - CI/CD流水线
   - 服务发现机制

#### 交付物
- 服务化架构设计
- 容器化方案
- 部署自动化

### 4.4 Phase 4: 微服务架构实施 (Month 3)

#### 目标
实施完整的微服务架构

#### 关键任务
1. **核心服务拆分**
   - 数据同步服务独立部署
   - 库存合并服务独立部署
   - 分析服务独立部署

2. **服务治理**
   - 服务注册与发现
   - 负载均衡
   - 熔断降级

3. **数据一致性**
   - 分布式事务处理
   - 数据同步策略
   - 一致性监控

#### 交付物
- 完整的微服务系统
- 服务治理体系
- 生产环境部署

## 5. 实施计划

### 5.1 技术选型

#### 后端技术栈
- **框架**：Python FastAPI (保持与现有项目一致)
- **数据库**：MySQL + Redis + ClickHouse
- **消息队列**：RabbitMQ
- **任务调度**：Celery
- **容器化**：Docker + Kubernetes

#### 前端技术栈
- **框架**：Vue.js 3 + TypeScript (参考data_project)
- **UI组件**：Element Plus / Ant Design Vue
- **图表库**：ECharts / Chart.js
- **构建工具**：Vite

### 5.2 开发团队结构

#### 核心开发团队
- **架构师** (1人)：负责整体架构设计和技术决策
- **后端开发** (2-3人)：负责核心业务逻辑实现
- **前端开发** (1-2人)：负责用户界面和交互
- **测试工程师** (1人)：负责测试策略和质量保证
- **运维工程师** (1人)：负责部署和运维

#### 协作方式
- **敏捷开发**：2周一个迭代
- **代码审查**：所有代码必须经过审查
- **持续集成**：自动化测试和部署
- **技术分享**：定期技术分享和知识沉淀

### 5.3 风险控制

#### 技术风险
1. **数据一致性风险**
   - 缓解措施：严格的事务管理和数据校验
   - 监控指标：数据一致性检查、异常报警

2. **性能风险**
   - 缓解措施：性能测试、容量规划
   - 监控指标：响应时间、吞吐量、资源使用率

3. **兼容性风险**
   - 缓解措施：充分的集成测试、灰度发布
   - 监控指标：接口兼容性、数据格式验证

#### 业务风险
1. **需求变更风险**
   - 缓解措施：需求冻结、变更评估流程
   - 应对策略：灵活的架构设计、模块化开发

2. **上线风险**
   - 缓解措施：分阶段上线、回滚方案
   - 应对策略：蓝绿部署、监控告警

## 6. 核心代码实现

### 6.1 库存合并器主模块

```python
# src/inventory/merger.py
from typing import List, Dict, Any
from src.models.product_analytics import ProductAnalytics
from src.inventory.eu_merger import EUMerger
from src.inventory.non_eu_merger import NonEUMerger
from src.inventory.ad_merger import AdMerger

class InventoryMerger:
    """库存点合并器主类"""
    
    def __init__(self):
        self.eu_merger = EUMerger()
        self.non_eu_merger = NonEUMerger()
        self.ad_merger = AdMerger()
    
    def merge_inventory_points(self, products: List[ProductAnalytics]) -> List[Dict[str, Any]]:
        """
        合并库存点数据
        
        Args:
            products: 原始产品数据列表
            
        Returns:
            合并后的库存点数据列表
        """
        if not products:
            return []
        
        # 按ASIN分组
        asin_groups = self._group_by_asin(products)
        
        merged_points = []
        
        for asin, asin_products in asin_groups.items():
            # 分离欧盟和非欧盟产品
            eu_products, non_eu_products = self._separate_by_region(asin_products)
            
            # 合并欧盟地区库存
            if eu_products:
                eu_merged = self.eu_merger.merge(eu_products)
                if eu_merged:
                    merged_points.append(eu_merged)
            
            # 合并非欧盟地区库存
            if non_eu_products:
                non_eu_merged = self.non_eu_merger.merge(non_eu_products)
                merged_points.extend(non_eu_merged)
        
        # 合并广告数据
        for point in merged_points:
            point = self.ad_merger.merge_ad_data(point)
        
        return merged_points
    
    def _group_by_asin(self, products: List[ProductAnalytics]) -> Dict[str, List[ProductAnalytics]]:
        """按ASIN分组产品"""
        groups = {}
        for product in products:
            asin = product.asin
            if asin not in groups:
                groups[asin] = []
            groups[asin].append(product)
        return groups
    
    def _separate_by_region(self, products: List[ProductAnalytics]) -> tuple:
        """分离欧盟和非欧盟产品"""
        eu_countries = {
            'FR', 'DE', 'IT', 'ES', 'PT', 'NL', 'BE', 'LU', 'AT', 
            'DK', 'SE', 'FI', 'EE', 'HR', 'SI', 'CZ', 'RO', 'BG', 
            'GR', 'CY', 'MT', 'IS', 'LI', 'MC', 'SM', 'VA'
        }
        
        eu_products = []
        non_eu_products = []
        
        for product in products:
            # 从店铺名称提取国家代码
            country_code = self._extract_country_code(product.store)
            if country_code in eu_countries:
                eu_products.append(product)
            else:
                non_eu_products.append(product)
        
        return eu_products, non_eu_products
    
    def _extract_country_code(self, store_name: str) -> str:
        """从店铺名称提取国家代码"""
        # 店铺名称格式: "03 ZipCozy-UK"
        if '-' in store_name:
            return store_name.split('-')[-1].strip()
        return ''
```

### 6.2 欧盟地区合并器

```python
# src/inventory/eu_merger.py
from typing import List, Dict, Any, Optional
from src.models.product_analytics import ProductAnalytics

class EUMerger:
    """欧盟地区库存合并器"""
    
    def merge(self, eu_products: List[ProductAnalytics]) -> Optional[Dict[str, Any]]:
        """
        合并欧盟地区库存数据
        
        实现两步合并逻辑：
        1. 每个店铺选出FBA可用+FBA在途最大的国家作为代表
        2. 将所有店铺代表合并为欧盟库存点
        """
        if not eu_products:
            return None
        
        # 第一步：按店铺前缀分组
        store_groups = self._group_by_store_prefix(eu_products)
        
        # 第二步：每个店铺选择最佳库存代表
        store_representatives = []
        for store_prefix, products in store_groups.items():
            representative = self._select_best_inventory_representative(products)
            if representative:
                store_representatives.append(representative)
        
        # 第三步：合并所有店铺代表
        if store_representatives:
            return self._merge_store_representatives(store_representatives)
        
        return None
    
    def _group_by_store_prefix(self, products: List[ProductAnalytics]) -> Dict[str, List[ProductAnalytics]]:
        """按店铺前缀分组"""
        groups = {}
        for product in products:
            store_prefix = self._extract_store_prefix(product.store)
            if store_prefix not in groups:
                groups[store_prefix] = []
            groups[store_prefix].append(product)
        return groups
    
    def _extract_store_prefix(self, store_name: str) -> str:
        """提取店铺前缀，如 "03 ZipCozy-UK" -> "03 ZipCozy" """
        if '-' in store_name:
            return store_name.split('-')[0].strip()
        return store_name
    
    def _select_best_inventory_representative(self, products: List[ProductAnalytics]) -> Optional[ProductAnalytics]:
        """选择FBA可用+FBA在途最大的产品作为代表"""
        if not products:
            return None
        
        best_product = products[0]
        max_inventory = (best_product.fba_available or 0) + (best_product.fba_inbound or 0)
        
        for product in products[1:]:
            current_inventory = (product.fba_available or 0) + (product.fba_inbound or 0)
            if current_inventory > max_inventory:
                max_inventory = current_inventory
                best_product = product
        
        return best_product
    
    def _merge_store_representatives(self, representatives: List[ProductAnalytics]) -> Dict[str, Any]:
        """合并所有店铺代表为欧盟库存点"""
        base_product = representatives[0]
        
        merged_data = {
            'asin': base_product.asin,
            'product_name': base_product.product_name,
            'sku': base_product.sku,
            'category': base_product.category,
            'sales_person': base_product.sales_person,
            'product_tag': base_product.product_tag,
            'marketplace': '欧盟',
            'store': '欧盟汇总',
            
            # 合并库存数据（累加）
            'fba_available': sum(p.fba_available or 0 for p in representatives),
            'fba_inbound': sum(p.fba_inbound or 0 for p in representatives),
            'fba_unsellable': sum(p.fba_unsellable or 0 for p in representatives),
            
            # 本地仓不累加（同一个仓库）
            'local_available': max(p.local_available or 0 for p in representatives),
            
            # 合并销售数据（累加）
            'sales_7days': sum(p.sales_7days or 0 for p in representatives),
            'total_sales': sum(p.total_sales or 0 for p in representatives),
            'average_sales': sum(p.average_sales or 0 for p in representatives),
            'order_count': sum(p.order_count or 0 for p in representatives),
            
            # 使用第一个产品的价格信息
            'average_price': base_product.average_price,
            'sales_amount': base_product.sales_amount,
            'net_sales': base_product.net_sales,
            'refund_rate': base_product.refund_rate,
        }
        
        return merged_data
```

### 6.3 处理器集成

```python
# src/processors/inventory_merge_processor.py
from typing import List, Dict, Any
from src.processors.base_processor import BaseProcessor
from src.inventory.merger import InventoryMerger
from src.models.inventory_details import InventoryDetails
from src.utils.logging_utils import get_logger

logger = get_logger(__name__)

class InventoryMergeProcessor(BaseProcessor):
    """库存合并处理器"""
    
    def __init__(self):
        super().__init__()
        self.merger = InventoryMerger()
    
    def process(self, data_list: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        处理库存合并逻辑
        
        Args:
            data_list: 原始库存数据列表
            
        Returns:
            处理结果
        """
        try:
            logger.info(f"开始处理库存合并，数据量: {len(data_list)}")
            
            # 数据预处理
            cleaned_data = self._clean_data(data_list)
            logger.info(f"数据清洗完成，有效数据量: {len(cleaned_data)}")
            
            # 转换为产品对象
            products = self._convert_to_products(cleaned_data)
            
            # 执行合并
            merged_points = self.merger.merge_inventory_points(products)
            logger.info(f"库存合并完成，合并后库存点数量: {len(merged_points)}")
            
            # 持久化结果
            saved_count = self._persist_data(merged_points)
            
            result = {
                'status': 'success',
                'processed_count': len(data_list),
                'cleaned_count': len(cleaned_data),
                'merged_count': len(merged_points),
                'saved_count': saved_count,
                'merged_points': merged_points
            }
            
            logger.info(f"库存合并处理完成: {result}")
            return result
            
        except Exception as e:
            logger.error(f"库存合并处理失败: {e}")
            return {
                'status': 'error',
                'error': str(e),
                'processed_count': len(data_list) if data_list else 0
            }
    
    def _clean_data(self, data_list: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """数据清洗"""
        cleaned = []
        for data in data_list:
            if self._validate_inventory_data(data):
                cleaned.append(self._normalize_data(data))
        return cleaned
    
    def _validate_inventory_data(self, data: Dict[str, Any]) -> bool:
        """验证库存数据完整性"""
        required_fields = ['asin', 'product_name', 'store', 'marketplace']
        return all(field in data and data[field] for field in required_fields)
    
    def _normalize_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """数据标准化"""
        # 确保数值字段为数字类型
        numeric_fields = [
            'fba_available', 'fba_inbound', 'local_available',
            'sales_7days', 'average_sales', 'order_count'
        ]
        
        for field in numeric_fields:
            if field in data:
                try:
                    data[field] = float(data[field]) if data[field] is not None else 0
                except (ValueError, TypeError):
                    data[field] = 0
        
        return data
    
    def _convert_to_products(self, data_list: List[Dict[str, Any]]) -> List:
        """转换为产品分析对象"""
        # 这里需要根据实际的ProductAnalytics模型进行转换
        products = []
        for data in data_list:
            # 创建产品对象...
            pass
        return products
    
    def _persist_data(self, merged_points: List[Dict[str, Any]]) -> int:
        """持久化合并结果"""
        saved_count = 0
        try:
            with self.get_db_session() as session:
                for point_data in merged_points:
                    # 创建InventoryDetails对象并保存
                    inventory_point = InventoryDetails(
                        asin=point_data['asin'],
                        marketplace=point_data['marketplace'],
                        merged_fba_available=point_data['fba_available'],
                        merged_fba_inbound=point_data['fba_inbound'],
                        # ... 其他字段
                    )
                    session.add(inventory_point)
                    saved_count += 1
                
                session.commit()
                
        except Exception as e:
            logger.error(f"数据持久化失败: {e}")
            raise
        
        return saved_count
```

## 7. 监控和运维

### 7.1 关键指标监控

#### 业务指标
- 库存合并成功率
- 数据处理延迟
- 合并前后数据一致性
- 库存点数量变化

#### 技术指标  
- 服务响应时间
- 内存使用率
- CPU使用率
- 数据库连接数

### 7.2 告警策略

#### 紧急告警
- 合并失败率 > 5%
- 响应时间 > 10秒
- 服务不可用

#### 警告告警
- 合并失败率 > 1%
- 响应时间 > 5秒
- 数据延迟 > 1小时

### 7.3 运维工具

#### 日志聚合
- ELK Stack (Elasticsearch + Logstash + Kibana)
- 集中化日志管理和分析

#### 监控系统
- Prometheus + Grafana
- 自定义业务指标监控

#### 链路追踪
- Jaeger
- 分布式请求追踪

## 8. 总结

本设计文档提供了一个完整的data-update项目库存点合并逻辑的设计方案，包括：

1. **全面的需求分析**：基于data_project的实际业务需求，设计了完整的合并逻辑
2. **系统性的技术债务评估**：识别了现有系统的优势和不足，提出了分阶段的改进建议
3. **前瞻性的微服务架构**：设计了可扩展的微服务架构，支持未来的业务增长
4. **可执行的演进路线图**：提供了分阶段的实施计划，降低了项目风险
5. **详细的代码实现**：提供了核心模块的代码实现，确保方案的可落地性

该设计方案在保持与现有系统兼容的同时，为系统的长期演进奠定了坚实的基础，能够有效支撑业务的快速发展需求。

---

**文档版本**: v1.0  
**创建日期**: 2025-07-25  
**最后更新**: 2025-07-25  
**作者**: Claude Code AI Assistant